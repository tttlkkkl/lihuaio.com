---
title: "基本排序算法总结"
date: 2020-06-06T15:03:40+08:00
draft: false
# mermaid: true
katex: true
tags:
- go
- 算法
---
## 引言
随着时间的推移已经记不清各种基本排序算法的差别在哪里，实际编程当中甚至分不清自己用了哪种排序。总结备忘一下，用 GO 语言加以实现。

## 时间复杂度和稳定性

- 稳定性指在排序数列中有多个相同的元素，经过排序后相同元素的位置没有发生改变则称为稳定排序算法，否则就是不稳定排序算法。

|排序算法|平均时间复杂度|最好情况|最坏情况|空间复杂度|排序方式|稳定性|
|---|---|---|---|---|---|---|
|冒泡排序|O($n^2$)|O(n)|O($n^2$)|O(1)|in-place|稳定|
|选择排序|O($n^2$)|O($n^2$)|O($n^2$)|O(1)|in-place|不稳定|
|插入排序|O($n^2$)|O(n)|O($n^2$)|O(1)|in-place|稳定|
|希尔排序|O(n log n)|O(n $log^2$ n|O(n $log^2$ n)|O(1)|in-place|不稳定|
|归并排序|O(n log n)|O(n log n)|O(n $log^2$ n)|O(n)|out-place|稳定|
|快速排序|O(n log n)|O(n log n)|$O(n^2)$|O(log n)|in-place|不稳定|
|堆排序|O(n log n)|O(n log n)|O(n log n)|O(1)|in-place|不稳定|
|计数排序|O(n+k)|O(n+k)|O(n+k)|O(k)|out-place|稳定|
|桶排序|O(n+k)|O(n+k)|O($n^2$)|O(n+k)|out-place|稳定|
|基数排序|O(n*k)|O(n*k)|O(n*k)|O(n+k)|out-place|稳定|

### 冒泡排序
重复遍历待排序数列，每次比较两个元素，顺序错误则进行交换，直到没有元素再需要交换。由于越小的数会慢慢“浮”到数列顶端，因此得名。

#### 算法步骤
- 比较相邻的元素。如果第一个比第二个大，就交换他们。
- 每一对相邻元素都做同样的对比交换工作，从开始第一对到结尾最后一对一趟遍历完成后最后一个元素是最大的元素。
- 针对所有的元素重复以上步骤，除了最后一个（优化后不再遍历已经对比过的元素）
- 持续对减少的元素做以上操作，直到没有一对数字需要比较。

![冒泡排序示意](/images/bubbleSort.gif "冒泡排序动图演示")

- 输入反序的时候最慢，但是这种情况下一个循环交换也能完成正序排序。
- 冒泡排序有进一步的优化算法。见以下代码示例。
#### 冒泡排序 GO 实现
```go

// BubbleSort 冒泡排序
func BubbleSort(s []int) {
	l := len(s)
	for i := 0; i < l; i++ {
		for j := 0; j < l-1-i; j++ {
			if s[j] > s[j+1] {
				s[j], s[j+1] = s[j+1], s[j]
			}
		}
	}
	fmt.Println("冒泡排序后：", s)
}

// OpBubbleSort 优化后的冒泡排序
// 在一趟排序中如果没有发生交换说明已经是有序的
// 可以直接停止排序
// 这个优化对性能提升没有太大帮助
func OpBubbleSort(s []int) {
	l := len(s)
	var flag bool
	for i := 0; i < l; i++ {
		flag = false
		for j := i + 1; j < l-i; j++ {
			for j := 0; j < l-1-i; j++ {
				if s[j] > s[j+1] {
					s[j], s[j+1] = s[j+1], s[j]
					flag = true
				}
			}
		}
		// 如果没有发生交换说民已经有序，直接返回
		if !flag {
			break
		}
	}
	fmt.Println("冒泡排序后：", s)
}
```

### 选择排序
一种简单直观的排序算法，时间复杂度都是 $O(n^2)$，唯一的好处是减少额外空间的占用。

#### 算法步骤
- 找到最大（小）元素放在数列起始位置。
- 在未排序序列中找到最大（小）的元素放到已排序序列末尾。
- 重复以上步骤。

![选择排序示意图](/images/selectionSort.gif "选择排序动图演示")

#### 选择排序 GO 实现
```go
// SelectSort 选择排序算法
// 升序排序
// 遍历 每次选择最小的数放在排序位置
func SelectSort(s []int) {
	l := len(s)
	fmt.Println(l, cap(s))
	for i := 0; i <= l; i++ {
		// 寻找[i,l)区间里的最小值,并交换
		for j := i + 1; j < l; j++ {
			if s[j] < s[i] {
				// 交换
				s[i], s[j] = s[j], s[i]
			}
		}
	}
	fmt.Println("选择排序后：", s)
}
```

### 插入排序

跟扑克牌排序一样，从未排序数列中取一个元素，在有序的序列中向后扫描，找到相应的位置并插入。

#### 算法步骤
- 将待排序数列的第一个元素当作一个有序序列，其余看成未排序序列。
- 扫描未排序序列，将扫描到的每个元素插入到有序序列的适当位置，如果相等则放在相等元素后面。

![插入排序示意图](/images/insertionSort.gif "插入排序动图演示")

- 和冒泡排序一样，插入排序也有一种优化算法，叫拆半插入。利用二分查找法的原理，先与以排序数列的(n/2)处元素比较，中间元素比它大则往前继续用折半法比较查找合适的插入位置，否则往后半区查找插入位置。

#### 插入排序 GO 实现

```go
// InsertionSort 插入排序
func InsertionSort(s []int) {
	for i := range s {
		// 已排序末位元素索引
		pk := i - 1
		// 待插入的元素
		cu := s[i]
		// 第一趟排序不会执行这个循环
		// 第二趟开始，从后往前遍历已排序数列与待插入元素比较
		// 如果已排序数列中的数大于待插入数则将其后移一个元素
		// 以为插入数腾出空间
		for pk >= 0 && s[pk] > cu {
			s[pk+1] = s[pk]
			pk--
		}
		// 第一趟循环，将第一个元素当作已排序
        // 第二趟开始，如果没有进入子循环（待插入数大于等于已排序末端元素）
        // 待插入数无需移动
		// 如果进入了子循环则相当于将待插入元素插入到比它大的元素前
		s[pk+1] = cu
	}
	fmt.Println("插入排序后：", s)
}
```

### 希尔排序算法

也叫递减增量排序算法，是插入排序的改进版本，它不是稳定算法。

根据插入排序的以下两个性质提出改进的：
- 插入排序对已有一定排序顺序的数据排序时效率更高，可以达到线性效率。
- 插入算法一般情况下是低效的，因为每次只能将数据移动一位。

基本思想：先将待排序数列分割成若干子序列分别进行直接插入，待到整个序列中的记录基本有序时，再对全体记录进行直接插入排序。

#### 算法步骤
- 选择一个增量序列 $t_1,t_2,t_3...,t_j,t_i,t_k 其中 t_i>t_j,t_k=1$。
- 按照增量个数 k，对序列进行增量排序。
- 每趟排序根据对应的增量 $t_i$，将待排序序列分割成若干长度为 m 的子序列，分别对各表进行直接插入排序，仅增量因子为 1 时，整个序列作为一个表来处理，表长度为整个序列的长度。

![希尔排序示例](/images/shellSort.gif "希尔排序算法动图演示")

#### 希尔排序 GO 实现
```go
func ShellSort(s []int) {
	l := len(s)
	gap := 1
	for gap < gap/3 {
		gap = gap*3 + 1
	}
	for gap > 0 {
		for i := gap; i < l; i++ {
			tmp := s[i]
			j := i - gap
			for j >= 0 && s[j] > tmp {
				s[j+gap] = s[j]
				j = j - gap
			}
			s[j+gap] = tmp
		}
		gap = gap / 3
	}
	fmt.Println("希尔排序后：", s)
}
```

## 说明
文中所涉及到的图片资料等源自：
- [《十大经典排序算法》](https://sort.hust.cc/)，[github](https://github.com/hustcc/JS-Sorting-Algorithm)。
- [《5分钟学算法》](https://www.cnblogs.com/fivestudy/p/10212306.html)