---
title: "TCP 连接管理"
date: 2020-05-16T19:44:21+08:00
draft: false
# mermaid: true
katex: true
tags:
- tcp
- net
- 笔记
---

UDP 是一个无连接协议，相比之下 TCP 需要处理连接建立，正常终止，以及重新启动等更多连接上的细节问题。图例：

![TCP 连接与终止](/images/tcp-connect.jpg "TCP 的连接与终止示意图·来源于网络")

## 三次握手

- 客户端发送一个 SYN 报文段，并指明想要连接的 IP 和端口号以及序列号，记为 ISN(c)，一般还会发送一个或多个其他选项。
- 服务器响应一个 SYN 报文段，包含其序列号，记为 ISN(s),为确认客户端的 SYN 服务器将 ISN(c) 加 1 作为 ACK 数值返回。每发送一个 SYN 序号加 1 ，丢失重传。
- 为确认服务端的 SYN ，客户端将 ISN(s) 加 1 作为 ACK 的数值返回。、

## 四次挥手

- 关闭发起方发送一个 FIN 段发送当前的序列号(K),以及一个 ACK 段用于确认对方最近一次发来的数据(L)。
- 被动关闭者将 K 的数值加 1 作为 ACK 值响应。表明已确认 FIN 。此时上层的应用程序会收到对端已提出关闭请求的反馈。
- 被动关闭方发送 FIN ，报文序号为 L。
- 为了完成连接的关闭，最后发送的报文还包含一个 ACK 用于确认上一个 FIN。如果出现 FIN 丢失的情况，那么发送方重新传输直到收到一个 ACK 确认为止。

## 半关闭

这种特性很少被应用程序使用。

一端可以发起自身连接关闭请求(FIN)，表明不会再向对端发送数据，但是可以接收来自对端的数据。当接收半关闭的一方发送完数据之后，发送 FIN 来关闭本方的连接，同时发出一个文件尾提示。最后这个 FIN 被确认后连接全部关闭。

## 同时打开与关闭

A 和 B 两个主机同时向对端（比如 A 主机通过 7777 端口向 B 8888 端口发送 AYN ，B 通过 8888 端口向 A 7777 端口发送 SYN）发送 SYN 。两个 SYN 分别被确认之后连接建立，所以这种情况下一个连接的建立经过四次握手。同时关闭连接和上文的`四次挥手`一致。

这种情况发生的也很少，防火墙打孔技术除外。

## 初始化序列号

- SYN 建立之前都会选择一个序列号。32位的计数器，每4微妙加 1 。
- 需要设法确保序列号不重叠否则可能会出现数据重复的情况，比如一个报文延时导致同一端口上的连接再次建立时才到达，此时需要通过 CRC 或者校验和确保在传输过程中没有出现任何错误。
- 序列号以及端口等报文数据可以被伪造从而导致传输安全问题，linux 和 windows 都是通过使序列号变得不可猜测来保障相对的安全。

## TCP 选项

|种类|长度|名称|描述|
|---|---|---|---|
|0|1|EOL|选项列表结束|
|1|1|NOP|无操作，用于填充|
|2|4|MSS|最大段大小|
|3|3|WSOPT|窗口缩放因子，窗口左偏移量|
|4|2|SACK-Permitted|发送者支持SACK选项|
|5|可变|SACK|SACK 阻塞，收到乱序数据|
|8|10|TSOPT|时间戳选项|
|28|4|UTO|用户超时，一段时间后的终止|
|29|可变|TCP-AO|认证选项，使用多种算法|
|253|可变|Experimental|保留供实验使用|
|254|可变|Experimental|保留供实验使用|

- MSS： 允许从对方接收到的最大数据段大小（不包括 TCP/IP头部），SYN 段指定。默认536字节，正好能组成 576 字节的最小IP数据报。ipv6中最大段大小的数值相应减少20个字节。发送 MSS 的一端表明不再接收超过此长度的数据报。
- SACK：SYN 中发送`允许选择确认`选项后，SACK 就可以包含在任何数据报中，用以告知对端已经接收到的有效数据序号范围（分为好多块，最大为3块），对端重发数据。长度为(8n+2)，增加的2个字节记录SACK的长度。
- WSOPT：窗口缩放因子 s ，最大 14 。控制窗口字段左移 s 位($2^s$)。TCP 使用一个32位的值来维护这个窗口大小。最大窗口大小 $6535*2^s = 1GB$。
- TSOPT：根据 ACK 估算往返时间以便进一步精确设置超时重传。同时为接收者提供了避免接收旧报文与判断旧报文段正确性的方法。被称为`防回绕序列号`。
- UTO：USER_TIMEOUT,一个比较新的选项。表明愿意等待 ACK 的最大时间，另一端不是一定要尊从。
 - 达到3次重传阈值时应该通知应用程序。
 - 超时大于100秒时应该关闭连接。
 - 长的等待时间设置会导致资源耗尽。
 - 短的超时时间设置会导致连接过早的断开。如拒绝服务攻击。
- TCP-AO：TCP 认证选项，是一个比较新的选项。连接之前通信双方共享一套密钥，用来计算一个散列值以验证数据在传输过程中是否被篡改过。

## 路径的最大传输单元发现
传输路径中存在最大传输单元大小比收发双方的最大段小的设备时，TCP 会执行路径最大传输单元发送过程，以调整数据包大小。


![TCP 状态机](/images/tcp-status.jpg "TCP 状态机·图片涞源于网络")

## TIME_WAIT状态

- 也称为 2MSL 等待状态。两倍于最大段生存期，有时被称作`加倍等待`。受 IP 协议 TTL 限制。
- 严格的实施中处于 2MSL 状态的端口不可被再次使用。
- 旨在等待重传的 FIN 以及最终确认的 ACK 。防止新的连接将上一个连接的延迟报文当作自身的合法报文。

一般而言，通常客户端执行关闭操作进入 TIME_WAIT 状态，被动关闭一端不直接进入 TIME_WAIT 状态。通常客户端使用操作系统分配的临时端口号，不存在 2MSL 等待问题。但是服务端关闭后立即以同一个端口启动会因为 2MSL 状态而无法启动。

## 静默等待时间

处于 2MSL状态的主机崩溃重启，并在同一端口启动连接将导致 2MSL 失去意义。此时建议的做法是 在连接开启前等待一个 MSL 的时间。但是这个设定一般来说没有实际意义，因为主机通常在 2MSL 等待时间后才会完成重启。上层应用程序如果采用了校验或者加密手段也很容易验证数据的正确性。

## FIN_WAIT_2 状态

发送一个 FIN 并且得到确认，除去半关闭的情况下 该端会进入 FIN_WAIT_2 状态。等待接收对端的 FIN 和文件末尾通知并且回馈 ACK。此时正在关闭的 TCP 才会转移至 TIME_WAIT 状态。也就是说连接的一端能够永远保持这种状态，另一端也会依然处于 CLOSE_WAIT 状态，直到应用程序关闭它。一般的在非进入半关闭状态时关闭发起端设置一个计时器，在一个计时周期内连接空闲则转移至 CLOSDE 状态。

## 重置报文段

当发现一个到达的报文段对于相关连接而言是不正确的时，TCP 就会发送一个 RST 重置报文段。

- 当端口未被侦听时发送 RST 重置报文段。